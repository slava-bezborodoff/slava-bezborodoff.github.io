<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Are you smart enough to work in Yandex? | Slava Bezborodov</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Are you smart enough to work in Yandex?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Are you smart enough to work in Yandex?" />
<meta property="og:description" content="Are you smart enough to work in Yandex?" />
<link rel="canonical" href="http://localhost:4000/python/algorithms/2018/08/30/are-you-smart-enough-to-work-in-yandex.html" />
<meta property="og:url" content="http://localhost:4000/python/algorithms/2018/08/30/are-you-smart-enough-to-work-in-yandex.html" />
<meta property="og:site_name" content="Slava Bezborodov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-30T12:41:38+03:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/python/algorithms/2018/08/30/are-you-smart-enough-to-work-in-yandex.html","headline":"Are you smart enough to work in Yandex?","dateModified":"2018-08-30T12:41:38+03:00","datePublished":"2018-08-30T12:41:38+03:00","description":"Are you smart enough to work in Yandex?","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/python/algorithms/2018/08/30/are-you-smart-enough-to-work-in-yandex.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Slava Bezborodov" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Slava Bezborodov</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Are you smart enough to work in Yandex?</h1>
    <p class="post-meta"><time class="dt-published" datetime="2018-08-30T12:41:38+03:00" itemprop="datePublished">
        Aug 30, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="are-you-smart-enough-to-work-in-yandex">Are you smart enough to work in Yandex?</h1>

<p>Yandex is a large IT company. It was the first time I tried to attend it. I couldn’t even imagine that the interview consists of four sessions, each session is about one hour. You have to talk with four different people in four different places and solve lots of problems and answer the questions. In Yandex they used to write the codes on blank papers or just on the walls - this is very convinient. There are two major requirements you should carry about.</p>

<ul>
  <li>Use an existing programming language to write your codes. You can use any language you prefer, but it can’t be a pseudo language.</li>
  <li>Your codes should be free of any compiler / interpreter errors.</li>
</ul>

<p>The recipe of success is handling edge cases. The more problems you solve and the less syntax and / or logical mistakes you make, the higher you are.</p>

<p>In Yandex they believe that you have to have basic algorithmic knowledges. If you do, you can do anything else. I’ve failed my first attempt to join Yandex and decided to share some of the problems I faced during the interview.</p>

<p>The list of problems.</p>

<ul>
  <li><a href="#vertical-line">Vertical line</a></li>
  <li><a href="#two-maximums">Two maximums</a></li>
  <li><a href="#zip-ints">Zip ints</a></li>
  <li><a href="#count-pairs">Count pairs</a></li>
  <li><a href="#set-difference">Set difference</a></li>
  <li><a href="#fifo-queue">FIFO queue</a></li>
  <li><a href="#palindrome">Palindrome</a></li>
  <li><a href="#reverse-linked-list">Reverse linked list</a></li>
  <li><a href="#sum-of-diagonals">Sum of diagonals</a></li>
</ul>

<h2 id="vertical-line">Vertical line</h2>

<p>For given set of two-dimensional points check if a vertical line deviding the points symmetrically exists or not.</p>

<hr />

<p>A pair of points <code class="highlighter-rouge">(X1, Y1)</code> and <code class="highlighter-rouge">(X2, Y2)</code> can be devided by a vertical line symmetrically if the equations <code class="highlighter-rouge">X1 + X2 = C</code> and <code class="highlighter-rouge">Y1 = Y2</code> are held. If we find the other pair for which <code class="highlighter-rouge">Y3 = Y4</code> is true, but <code class="highlighter-rouge">X3 + X4 != C</code>, we cannot devide this set of points by a vertical line symmetrically. And finnaly, if we don’t determine the constant <code class="highlighter-rouge">C</code>, we can’t devide the set too.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="n">seen</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">seen</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seen</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>This algorithm takes O(n) time, but uses additional memory. In the worst case, when all the <code class="highlighter-rouge">Y</code>s are different, we will have a full copy of the source set of points requiring O(n) additional memory.</p>

<h2 id="two-maximums">Two maximums</h2>

<p>Find two maximums in unsorted array.</p>

<hr />

<p>We can simply scan the array and check each value. Don’t forget about corner cases.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_maxs</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="n">max1</span> <span class="o">=</span> <span class="n">max2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max1</span><span class="p">,</span> <span class="n">max2</span>

    <span class="n">max1</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max1</span><span class="p">,</span> <span class="n">max2</span>

    <span class="n">max2</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">max1</span> <span class="o">&lt;</span> <span class="n">max2</span><span class="p">:</span>
        <span class="n">max1</span><span class="p">,</span> <span class="n">max2</span> <span class="o">=</span> <span class="n">max2</span><span class="p">,</span> <span class="n">max1</span>

    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">max1</span><span class="p">:</span>
            <span class="n">max2</span> <span class="o">=</span> <span class="n">max1</span>
            <span class="n">max1</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">max2</span><span class="p">:</span>
            <span class="n">max2</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">max1</span><span class="p">,</span> <span class="n">max2</span>
</code></pre></div></div>

<p>This algorithm takes O(n) time and O(1) additional memory.</p>

<h2 id="zip-ints">Zip ints</h2>

<p>For given array of non repeatable integers print a string of shortened sequences. For example, for array <code class="highlighter-rouge">[4, 1, 2, 6, 3, 9, 7]</code> the output is <code class="highlighter-rouge">"1-4,6-7,9"</code>.</p>

<hr />

<p>In order to find the sequences to compress it’s better to have the source array sorted. In a sequence for the previous element and for the current element the equation <code class="highlighter-rouge">current = previous + 1</code> is held.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">zip_ints</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">''</span>

    <span class="n">sorted_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">sorted_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">zipped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sorted_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">begin</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">zipped</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">f'</span><span class="si">{</span><span class="n">begin</span><span class="si">}</span><span class="s">-</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zipped</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">f'</span><span class="si">{</span><span class="n">begin</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">if</span> <span class="n">begin</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">zipped</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">f'</span><span class="si">{</span><span class="n">begin</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zipped</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">f'</span><span class="si">{</span><span class="n">begin</span><span class="si">}</span><span class="s">-</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

    <span class="k">return</span> <span class="s">','</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span>
</code></pre></div></div>

<p>In Python built-in <code class="highlighter-rouge">sorted</code> method uses the <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> algorithm to sort sequences. In the worst-case it takes O(n log n) time and O(n) additional space. Iteration through the sorted array takes O(n) time, thus the total time complexity of this algorithm is O(n log n).</p>

<h2 id="count-pairs">Count pairs</h2>

<p><code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are sorted arrays. Count the pairs for which the equation <code class="highlighter-rouge">a + b = x</code> is held.</p>

<hr />

<p>To solve the problem effectively, we have to scan both arrays in the same loop. The first array (<code class="highlighter-rouge">A</code>) we scan from the beginning down to the end (forward scan using <code class="highlighter-rouge">i</code> as an index), the second one (<code class="highlighter-rouge">B</code>) - from the end up to the beginning (backward scan using <code class="highlighter-rouge">j</code> as an index). There are three possible cases.</p>

<ol>
  <li><code class="highlighter-rouge">A[i] + B[j] &lt; x</code> - the sum is less then <code class="highlighter-rouge">x</code> - we increase the sum by increasing the index <code class="highlighter-rouge">i</code> (move forward along the <code class="highlighter-rouge">A</code> array).</li>
  <li><code class="highlighter-rouge">A[i] + B[j] &gt; x</code> - the sum is more then <code class="highlighter-rouge">x</code> - we decrease the sum by decreasing the index <code class="highlighter-rouge">j</code> (move backward along the <code class="highlighter-rouge">B</code> array).</li>
  <li><code class="highlighter-rouge">A[i] + B[j] = x</code> - the sum is equal to <code class="highlighter-rouge">x</code> - we increase a count of found pairs. The number of increasing depends on the number of the same values placed together in <code class="highlighter-rouge">A</code> or <code class="highlighter-rouge">B</code> (sequences of the save values).</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_count</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">count_a</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">count_a</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">count_b</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">count_b</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">count_a</span> <span class="o">*</span> <span class="n">count_b</span>
    <span class="k">return</span> <span class="n">total</span>
</code></pre></div></div>

<p>The algorithm takes O(n+k) time and O(1) additional memory.</p>

<h2 id="set-difference">Set difference</h2>

<p><code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are sorted arrays. Find elements contained in <code class="highlighter-rouge">A</code> and not contained in <code class="highlighter-rouge">B</code>.</p>

<hr />

<p>The problem is to find a set difference between <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, but we have lists instead of sets. The lists are sorted, we can use that to find the result effectively.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">result</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>We start processing <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> from the beginnig. We compare current elements. If we find, that an element from <code class="highlighter-rouge">A</code> is less, we will include it to the answer. Otherwise we move current positions <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">j</code> forward.</p>

<p>The loop terminates if all the elements from <code class="highlighter-rouge">A</code> or <code class="highlighter-rouge">B</code> are processed. If <code class="highlighter-rouge">B</code> is shorter, we have to add to the answer the rest elements from <code class="highlighter-rouge">A</code> starting from the current position.</p>

<p>This algorithm takes O(n+k) time and O(1) additional memory.</p>

<h2 id="fifo-queue">FIFO queue</h2>

<p>Create a FIFO queue using two stacks.</p>

<hr />

<p>FIFO queue is a queue where the oldest (first) item is processed first. In Python we have no special class for stacks, we can use lists instead.</p>

<p>The idea is to put incoming elements in the first stack. When the element is aquired, we have to turn the first stack and return an item from top of the second stack.</p>

<p>We can create a simple class that implements queue interface.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FifoQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_instack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_outstack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_instack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">_outstack</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_turn</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_outstack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_turn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_instack</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_outstack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_instack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
</code></pre></div></div>

<p>The usage of the <code class="highlighter-rouge">FifoQueue</code> class is simple. We have only 2 public methods. When we need to store data, the method <code class="highlighter-rouge">enqueue</code> is used. When we need stored data back, we call the <code class="highlighter-rouge">dequeue</code> method.</p>

<h2 id="palindrome">Palindrome</h2>

<p>Check wheather a string is a palindrome or not. Non-alphanumeric characters are ignored. Case insensitive.</p>

<hr />

<p>A palindrome - reading a word from left to right is equal reading a word from right to left. For example, ignoring the difference between uppercase and lowercase letters and skipping non-alphanumeric characters, the string <code class="highlighter-rouge">Abcba!</code> is a palindrome, while the string <code class="highlighter-rouge">Hello</code> is not.</p>

<p>Whereas there is a beautiful recursive solution, it takes additional memory per each recursion call and is not so effective as an iteration-based one.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>This algorithm takes O(n) time and O(1) additional memory.</p>

<h2 id="reverse-linked-list">Reverse linked list</h2>

<p>Reverse given linked list.</p>

<hr />

<p>For that problem we need to define a new data type for linked list. For example, it may look like the following.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">NoReturn</span><span class="p">,</span> <span class="n">Optional</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="nb">next</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s">'Node'</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>
</code></pre></div></div>

<p>Class <code class="highlighter-rouge">Node</code> defines a type for an item of the linked list. Each node has a payload (value of any type) and a pointer to the next node (the <code class="highlighter-rouge">next</code> attribute). If the node has no next node, we call it a <em>tail</em> node.</p>

<p>Using this data structure, a regular python list <code class="highlighter-rouge">[1, 2, 3, 4, 5]</code> can be represented like that.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tail</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The problem is to reverse given linked list, i.e. make tail node a head for the new linked list.</p>

<p>Usually we process such structures using iteration. For example, a function that prints linked list can be written like this.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_list</span><span class="p">(</span><span class="n">head</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<p>Using such iteration pattern, we can walk through the list and swap the pointers of the two neighbour nodes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">head</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">previous</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="k">return</span> <span class="n">previous</span>
</code></pre></div></div>

<p>This algorithm makes changes <em>in-place</em>, i.e. it modifies an existing list. We can accept such behaviour for the sake of taking O(n) time and requiring O(1) additional memory.</p>

<h2 id="sum-of-diagonals">Sum of diagonals</h2>

<p>Find the sum of the diagonals of the square matrix.</p>

<hr />

<p>In order to solve the problem, we need to sum all the diagonal elements. We call an element <em>diagonal</em> if it’s row index and column index are the same. Obviously, the algorithm has to take O(n) time to find the sum.</p>

<p>The first thing we should do is to understand how to process all the diagonal elements using only one loop iteration. For instance, let’s consider a square matrix of size <code class="highlighter-rouge">4</code>.</p>

<p align="center">
<img src="/assets/img/matrix-4x4.png" alt="Square matrix of size 4" width="400px" />
</p>

<p>As we can see, in that case the sum is (1 + 6 + 11 + 16) + (4 + 7 + 10 + 13) = 68. The indices (X, Y) of the diagonal 1-6-11-16 are changing together from 1 up to 4. For the other diagonal 4-7-10-13 row X-index is changing from 1 up to 4, whereas column Y-index is changing from 4 down to 1. Keeping this in mind, let’s try to build the first version of the algorithm.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_diagonal_sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">s</span>

<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">get_diagonal_sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>For our sample matrix this algorithm returns 68 and takes O(n) time. Let’s consider another example.</p>

<p align="center">
<img src="/assets/img/matrix-3x3.png" alt="Square matrix of size 3" width="400px" />
</p>

<p>For that matrix the algorithm returns 30 instead of 25: central cell with value 5 is processed twice. Instead of making conditional check each loop iteration, we can subtract central cell before the result is returned.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_diagonal_sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">-</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">s</span>
</code></pre></div></div>

<p>As you can see, now the algorithm returns correct result. This solution takes O(n) time and O(1) additional memory. The algorithm works for any other edge cases, e.g. matrices of 1 element or empty matrices.</p>

  </div><a class="u-url" href="/python/algorithms/2018/08/30/are-you-smart-enough-to-work-in-yandex.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>My journey in the world.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://www.facebook.com/slava.bezborodoff" title="slava.bezborodoff"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg></a></li><li><a rel="me" href="https://github.com/slava-bezborodoff" title="slava-bezborodoff"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.instagram.com/slava.bezborodoff" title="slava.bezborodoff"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/slava-bezborodoff" title="slava-bezborodoff"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://t.me/slava_bezborodoff" title="slava_bezborodoff"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#telegram"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
